#include <stdio.h>
#include <sys/ipc.h>
#include <sys/wait.h>
#include <unistd.h>
#include <getopt.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>

#include "pipe-common.h"
#include "pipe-message.h"

#define version "20200423"





void cmHelp();

void cmVersion();



int main(int argc, char *argv[]){
  pid_t pid = -1;
  char *ptr;
  char *messageText = "This is the default message text";
  int secondReceive = 1;
  int secondSend = 1;
  int timesReceive = -1;
  int timesSend = 1;
  pipe_message_t message;
  int option_index = 0;
  int opt_long;
  int fd[2] = {-1};
  static struct option long_options[] = {
    {"help", no_argument, 0, 'h'},
    {"seconds-for-receiving", required_argument, 0, 'r'},
    {"seconds-for-sending", required_argument, 0, 's'},
    {"times-for-receiving", required_argument, 0, 't'},
    {"times-for-sending", required_argument, 0, 'u'},
    {"version", no_argument, 0, 'v'},
    {"message-text", required_argument, 0, 'x'},
    {0, 0, 0, 0}
  };


  if(pipe_message_set_text(&message, messageText) == -1){
    fprintf(stderr, "%s:%s:%d: Unable to set the \"%s\" message text.\n", argv[0], __FILE__, __LINE__, messageText);
    return 1;
  }


  while ((opt_long = getopt_long(argc, argv, "hr:s:t:u:vx:", long_options, &option_index)) != -1){
    switch(opt_long){
      case 'h':
        cmHelp();
        return 0;
        break;
      case 'v':
        cmVersion();
        return 0;
        break;
      case 'r':
        if(optarg){
          secondReceive = strtol(optarg, &ptr, 10);
          if((errno != 0) || (*ptr != '\0')){
            fprintf(stderr, "%s:%s:%d: Invalid parameter for the r command\n", argv[0], __FILE__, __LINE__);
            return 1;
          }
        }
        break;
      case 's':
        if(optarg){
          secondSend = strtol(optarg, &ptr, 10);
          if((errno != 0) || (*ptr != '\0')){
            fprintf(stderr, "%s:%s:%d: Invalid parameter for the s command\n", argv[0], __FILE__, __LINE__);
            return 1;
          }
        }
        break;
      case 'x':
        if(optarg){
          if(pipe_message_set_text(&message, optarg) == -1){
            fprintf(stderr, "%s:%s:%d: Unable to set the \"%s\" message text.\n", argv[0], __FILE__, __LINE__, optarg);
            return 1;
          }
        }
        break;
      case 't':
        if(optarg){
          timesReceive = strtol(optarg, &ptr, 10);
          if((errno != 0) || (*ptr != '\0')){
            fprintf(stderr, "%s:%s:%d: Invalid parameter for the t command\n", argv[0], __FILE__, __LINE__);
            return 1;
          }
        }
        break;
      case 'u':
        if(optarg){
          timesSend = strtol(optarg, &ptr, 10);
          if((errno != 0) || (*ptr != '\0')){
            fprintf(stderr, "%s:%s:%d: Invalid parameter for the u command\n", argv[0], __FILE__, __LINE__);
            return 1;
          }
        }
        break;
      case '?':
        return 1;
    }
  }


  if(pipe2(fd, O_NONBLOCK) == -1){
     fprintf(stderr, "%s:%s:%d: Unable to setup the pipe.\n", argv[0], __FILE__, __LINE__);
    return 1;
  }

  pid = fork();

  switch(pid){
    case -1:
      fprintf(stderr, "%s:%s:%d: Unable to create the subprocess.\n", argv[0], __FILE__, __LINE__);
      return 1;
      break;

    case 0:
      pipe_message_set_pid(&message, getpid());
      while(timesSend != 0){
        if(timesSend > 0){
          timesSend --;
        }
        if(pipe_write(fd[1], message) == -1){
          fprintf(stderr, "%s:%s:%d: Unable to send the message.\n", argv[0], __FILE__, __LINE__);
          return 1;
        }
        if(secondSend > 0){
          if(timesSend != 0){
            sleep(secondSend);
          }
        }else{
          fprintf(stdout, "Press the Enter key to continue...\n");
          while ((getchar()) != '\n');
        }
      }
      break;

    default:
      while(timesReceive != 0){
        if(timesReceive > 0){
          timesReceive --;
        }
        pipe_read(fd[0]);
        if(secondReceive > 0){
          if(timesReceive != 0){
            sleep(secondReceive);
          }
        }else{
          fprintf(stdout, "Press the Enter key to continue...\n");
          while ((getchar()) != '\n');
        }
      }
      wait(NULL);
  }


  return 0;
}





void cmHelp(){
  fprintf(stdout, "Usage: ./pipe-main.out [OPTION]...\n");
  fprintf(stdout, "Send and receive messages through a pipe.\n");
  fprintf(stdout, "\nOptions:\n");
  fprintf(stdout, "\t-h, --help\n");
  fprintf(stdout, "\t\tdisplay this help and exit\n");
  fprintf(stdout, "\t-r, --seconds-for-receiving=SECONDS\n");
  fprintf(stdout, "\t\tset the seconds between each try to receive a message (the default value is \"1\", a value less than or equal to 0 enables the interactive mode where the input stream is read)\n");
  fprintf(stdout, "\t-s, --seconds-for-sending=SECONDS\n");
  fprintf(stdout, "\t\tset the seconds between each try to send a message (the default value is \"1\", a value less than or equal to 0 enables the interactive mode where the input stream is read)\n");
  fprintf(stdout, "\t-t, --times-for-receiving=TIMES\n");
  fprintf(stdout, "\t\tset the number of times this program tries to receive a message (the default value is \"-1\", a negative value means repeat for ever)\n");
  fprintf(stdout, "\t-u, --times-for-sending=TIMES\n");
  fprintf(stdout, "\t\tset the number of times this program tries to send a message (the default value is \"1\", a negative value means repeat for ever)\n");
  fprintf(stdout, "\t-v, --version\n");
  fprintf(stdout, "\t\toutput version information and exit\n");
  fprintf(stdout, "\t-x, --message-text=TEXT\n");
  fprintf(stdout, "\t\tset the message text to TEXT (the default value is \"This is the default message text\")\n");
  fprintf(stdout, "\nReport bugs to Benjamin Coppens Bioux <benjamin.coppens-bioux@etud.univ-pau.fr> and liam Didriche <liam.didriche@etud.univ-pau.fr>.\n");
}

void cmVersion(){
  fprintf(stdout, "pipe-main %s\n", version);
  fprintf(stdout, "\nCopyright (C) 2020 Benjamin Coppens Bioux and liam Didriche.\n");
  fprintf(stdout, "\nWritten by Benjamin Coppens Bioux <benjamin.coppens-bioux@etud.univ-pau.fr> and liam Didriche <liam.didriche@etud.univ-pau.fr>.\n");
}
